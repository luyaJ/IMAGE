## 创建对象有几种方法

创建对象有下面3中方法：

```js
// 第1种方法：字面量
var obj1 = { name: 'obj1' };   
var obj2 = new Object({ name: 'obj2' });  

// 第2种方法：构造函数
var Fn = function() { this.name = 'obj3'; }
var obj3 = new Fn();                      

// 第3种方法：Object.create
var P = { name: 'obj4' };
var obj4 = Object.create(P);
```

## 基本概念

在上面的几个例子中，`obj1, obj2, obj3, P, obj4`都是**实例**。

任何一个被`new`使用的函数都是**构造函数**

![原型图](http://p8inmak9c.bkt.clouddn.com/proto%E5%9B%BE.png)

## prototype 显式原型

**每个函数都有一个`prototype`属性。**

这个`prototype`的属性值是一个对象（对象是属性的集合），默认的只有`constructor`属性，**指向这个函数的本身**。

![prototype属性](http://p8inmak9c.bkt.clouddn.com/proto1.png)

上面这个图中，superType是一个函数，右边的方框是它的**原型**。

也就是说，有这样一些规则：
```js
let Fn = function() { 
  name: 'luyaj'
};
let f = new Fn();

Fn.prototype;   // {constructor: ƒ}
Fn.prototype.constructor;   // ƒ (){name: 'luyaj'}
Fn.prototype.constructor == Fn;   // true
```

原型既然作为对象，属性的结合，就会有很多的属性，并且可以自定义属性。

![原型的属性](http://p8inmak9c.bkt.clouddn.com/%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7.png)

所以，我们可以在自己定义的方法的prototype中新增自己的属性：

```js
function Fn() { }
  Fn.prototype.name = 'luyaj';
  Fn.prototype.getYear = function () {
    return 1995;
};
```

所以就成了这样的：

![原型的属性的实例](http://p8inmak9c.bkt.clouddn.com/%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A72.png)

接着，我们继续：

```js
function Fn() {
  Fn.prototype.name = 'luyaj';
  Fn.prototype.getYear = function() {
    return 1995;
  }
}

let fn = new Fn();
console.log(fn.name);   // luyaj
console.log(fn.getYear());   // 1995
```

所以，Fn是一个函数，fn的对象是从Fn函数中new出来的，这样fn对象就可以调用Fn.prototype中的属性。

## __proto__ 隐式原型

**每个对象都有一个隐藏的属性 __proto__**，这个属性引用了创建这个对象的函数的prototype。即`Fn.prototype === fn.__proto__`。

![原型图](http://p8inmak9c.bkt.clouddn.com/proto.png)

## instanceof

`instanceof`运算符的第一个变量是对象，第二个变量一般是一个函数。

```js
function Foo() {};
var f1 = new Foo();

f1 instanceof Foo;   // true
f1 instanceof Object;   // true
```

在上图中，我们沿着`f1的__proto__`这条线来找，同时沿着函数的prototype这条线来找。如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果到了终点还未重合，就返回false。

## 继承

js中的继承是通过原型链来实现的。

```js
function Foo() {}
var f1 = new Foo();

f1.a = 10;

Foo.prototype.a = 100;
Foo.prototype.b = 200;

f1.a;   // 100
f1.b;   // 200
```

上面代码中，f1是Foo函数new出来的实例，f1.a是f1对象的基本属性，那么，f1.b是怎么来的呢？

**当我们访问一个对象的属性时，现在基本属性中查找，如果没有，就沿着__proto__这条链向上找，这就是原型链。**

我们来解释一下：

![原型链](http://p8inmak9c.bkt.clouddn.com/%E5%8E%9F%E5%9E%8B%E9%93%BE.png)

访问`f1.b`时，f1的属性中是没有b的，于是就沿着`__proto__`找到了`Foo.prototype.b`。

那么实际中，我们如何区分一个属性是基本的还是从原型中找到的呢？

那么我们使用`hasOwnProperty`来检测：
```js
function Foo() {}
var f1 = new Foo();

f1.a = 10;

Foo.prototype.a = 100;
Foo.prototype.b = 200;

var item;
for(item in f1) {
  console.log(item);
}
// a
// b
```

```js
function Foo() {}
var f1 = new Foo();

f1.a = 10;

Foo.prototype.a = 100;
Foo.prototype.b = 200;

var item;
for(item in f1) {
  if(f1.hasOwnProperty(item)) {
    console.log(item);
  }
}
// a
```

但是，`hasOwnProperty`是从哪里来的呢？

```js
Foo.prototype   // {a: 100, b: 200, constructor: ƒ}
f1    // Foo {a: 10}
Object.prototype
// constructor hasOwnProperty isPrototypeOf propertyIsEnumerable
// toLocaleString toString valueOf 等等属性

```

在控制台中打印的结果显示，`f1`和`Foo.prototype`都没有这个属性，它是从`Object.prototype`中来的。

对象的原型链是沿着`__proto__`这条线走的，因此在查找`f1.hasOwnProperty`属性时，就会顺着原型链一直查找到`Object.prototype`。

由于所有的对象的原型链都会找到`Object.prototype`，因此所有的对象都会有`Object.prototype`的方法。这就是所谓的“**继承**”。

当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。
