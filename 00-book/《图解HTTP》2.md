---
title: 《图解HTTP》2
toc: true
date: 2018-05-31 15:49:43
tags: HTTP
categories: 书籍
---

《图解HTTP》第6章及之后内容。感觉看了这本书后，又接收到了很多新的知识。

<!--more-->

# HTTP首部

HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分贝处理请求和响应提供所需要的信息。对于客户端用户来说，这些信息中的大部分内容都无须亲自查看。

![请求报文和响应报文](http://p983im8gr.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png)

## HTTP 首部字段

**HTTP 首部字段结构**

HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:”分隔。

```bash
首部字段名：字段值

Content-Type: text/html
Keep-Alive: timeout=15, max=100
```

**HTTP 首部字段类型**

* 通用首部字段(General Header Fields)：请求报文和响应报文两方都会使用的首部
* 请求首部字段(Request Header Fields)：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。
* 响应首部字段(Response Header Fields)：从服务器端向客户端返回响应报文时使用的首部。
* 实体首部字段(Entity Header Fields)：针对请求报文和响应报文的实体部分使用的首部。

**End-to-end 首部和 Hop-by-hop 首部**

HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分为两种类型。

* 端到端首部（End-to-end Header）
  * 分在此类别中的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定她必须被转发。
* 逐跳首部（Hop-by-hop Header）
  * 分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后的版本，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。

以下是 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外，其他所有字段都属于端到端首部。

* Connection
* Keep-Alive
* Proxy-Authenticate
* Proxy-Authorization
* Trailer
* TE
* Transfer-Encoding
* Upgrade


# 确保 Web 安全的 HTTPS

## HTTP的缺点

万事皆有两面性，前面我们讲的都是 HTTP 的优点，现在我们讲讲它的不足：

* 通信使用明文（不加密），内容可能会被窃听
* 不验证通信方的身份，因此有可能遭受伪装
* 无法证明报文的完整性，所以有可能已遭篡改

这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题。

### 通信使用明文可能会被窃听

HTTP 本身不具备加密功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即 HTTP 报文使用明文（指未经过加密的报文）方式发送。

**TCP/IP 是可能被窃听的网络**。在网络中，即使是已经经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。

窃听相同段上的通信并非难事，只需要收集在互联网上流动的数据包（帧）就行了。对于收集来的数据包的解析工作，可交给那些抓包或嗅探器工具。被广泛使用的抓包工具有 Wireshark。

在目前大家正在研究的如何窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有这么几个：

**1.通信的加密：**

HTTP 协议中没有加密机制，但可以通过和 SSL 或 TLS 的组合使用，加密 HTTP 的通信内容。

用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。

**2.内容的加密：**

由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。

这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。

### 不验证通信方的身份就可能遭遇伪装

HTTP 协议中的请求和响应不会对通信方进行确认。也就说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等问题。

在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，**任何人都可以发起请求**。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应。所以存在以下隐患：

* 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。
* 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。
* 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。无法判定请求是来自何方、出自谁手。
* 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。

### 无法证明报文完整性，可能已遭篡改

由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。

## http + 加密 + 认证 + 完整性保护 = https

https 是身披 ssl 外壳的 http。

# 确认访问用户身份的认证

某些 Web 页面只想让特定的人浏览，或者干脆仅本人可见。为达到这个目标，必不可少的就是认证功能。

## 何为认证

计算机本身无法判断坐在显示器前的使用者的身份。进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清楚究竟是谁在访问服务器，就得让对方的客户端自报家门。

可是，就算正在访问服务器的对方声称自己是 ueno，身份是否属实还是不能确定。为确认 ueno 本人是否真的具有访问系统的权限，就需要核对“只有登录本人才知道才有的信息”。

核对的信息通常指以下这些：

* 密码：只有本人才会知道的字符串信息
* 动态令牌：仅限本人持有的设备内显示的一次性密码
* 数字证书：仅限本人（终端）持有的信息
* 生物认证：指纹和虹膜等本人的生理信息
* IC 卡等：仅限本人持有的信息

HTTP/1.1 使用的认证方式如下：

* BASIC 认证（基本认证）
* DIGEST 认证（摘要认证）
* SSL 客户端认证
* FormBase 认证（基于表单认证）

## BASIC 认证

BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是 Web 服务器与通信客户端之间进行的认证方式。

BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户 ID 和 密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。

除此之外，想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作。且 BASIC 认证使用上不够便捷灵活。

## DIGEST 认证

为了弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。DIGEST 认证同样使用质询/响应的方式(challenge/response)，但不会像 BASIC 认证那样直接发送明文密码。

所谓**质询响应方式**是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接听到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。

## SSL 客户端认证

SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。

SSL 客户端认证

## 基于表单认证

基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息，按登录信息的验证结果认证。

**认证多半是基于表单认证**

# 基于 http 的功能追加协议

SPDY 开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间。

![以前的http](http://p983im8gr.bkt.clouddn.com/%E4%BB%A5%E5%89%8D%E7%9A%84http.png)

使用 HTTP 协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。

## ajax解决方法

Ajax（异步的JavaScrpt与XML技术）是一种有效利用 JavaScript 和 DOM 的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。

但利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生，另外，Ajax 仍未解决 HTTP 协议本身存在的问题。

## Comet的解决办法

一旦服务器端有内容更新，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送的功能。

通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。

内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。例外，Comet 也仍未解决 HTTP 协议本身存在的问题。

![commet通信](http://p983im8gr.bkt.clouddn.com/comet%E9%80%9A%E4%BF%A1.png)

## SPDY的目标